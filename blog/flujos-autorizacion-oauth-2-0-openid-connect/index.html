<!DOCTYPE html>
<html lang="es-ES">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Flujos de autorización con OAuth 2.0 y OpenID Connect | Rafael Neto</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="icon" href="/images/logo.png">
    <link rel="manifest" href="/manifest.json">
    <link rel="apple-touch-icon" href="/images/icons/icon-152x152.png">
    <link rel="mask-icon" href="/icons/safari-pinned-tab.svg" color="#d66056">
    <script async="true" src="https://www.googletagmanager.com/gtag/js?id=G-S8PRT356B6"></script>
    <script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-S8PRT356B6', { 'anonymize_ip': true });</script>
    <link rel="alternate" type="application/rss+xml" href="https://rafaelneto.dev/rss.xml" title="Rafael Neto RSS Feed">
    <meta name="description" content="Un flujo de autorización es lo que permite que una aplicación cliente, como aplicaciones web, aplicaciones de escritorio, teléfonos móviles, dispositivos IoT y otros consumidores, obtengan acceso autorizado a recursos protegidos, como APIs web y archivos entre otros.">
    <meta property="article:published_time" content="2023-02-28T00:00:00.000Z">
    <meta property="og:site_name" content="Rafael Neto">
    <meta property="og:title" content="Flujos de autorización con OAuth 2.0 y OpenID Connect">
    <meta property="og:description" content="Un flujo de autorización es lo que permite que una aplicación cliente, como aplicaciones web, aplicaciones de escritorio, teléfonos móviles, dispositivos IoT y otros consumidores, obtengan acceso autorizado a recursos protegidos, como APIs web y archivos entre otros.">
    <meta property="og:type" content="website">
    <meta property="og:url" content="/blog/flujos-autorizacion-oauth-2-0-openid-connect/">
    <meta name="twitter:title" content="Flujos de autorización con OAuth 2.0 y OpenID Connect">
    <meta name="twitter:description" content="Un flujo de autorización es lo que permite que una aplicación cliente, como aplicaciones web, aplicaciones de escritorio, teléfonos móviles, dispositivos IoT y otros consumidores, obtengan acceso autorizado a recursos protegidos, como APIs web y archivos entre otros.">
    <meta name="twitter:url" content="/blog/flujos-autorizacion-oauth-2-0-openid-connect/">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:label2" content="Filed under">
    <meta name="twitter:data2" content="ASPNETCore, AzureAD, OAuth2, OIDC, seguridad">
    <meta property="article:tag" content="ASPNETCore">
    <meta name="theme-color" content="#d66056">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="msapplication-TileImage" content="/images/icons/icon-144x144">
    <meta name="msapplication-TileColor" content="#000000">
    
    <link rel="preload" href="/assets/css/0.styles.bb0c19ce.css" as="style"><link rel="preload" href="/assets/js/app.ee019d85.js" as="script"><link rel="preload" href="/assets/js/4.35e6b205.js" as="script"><link rel="preload" href="/assets/js/1.801c1b6e.js" as="script"><link rel="preload" href="/assets/js/67.08618c54.js" as="script"><link rel="prefetch" href="/assets/js/11.7f50e1d9.js"><link rel="prefetch" href="/assets/js/12.e5fcd202.js"><link rel="prefetch" href="/assets/js/13.89648ad6.js"><link rel="prefetch" href="/assets/js/14.c6a608cd.js"><link rel="prefetch" href="/assets/js/15.00d4c987.js"><link rel="prefetch" href="/assets/js/16.f0891c93.js"><link rel="prefetch" href="/assets/js/17.93778a3e.js"><link rel="prefetch" href="/assets/js/18.1468113e.js"><link rel="prefetch" href="/assets/js/19.40f9e796.js"><link rel="prefetch" href="/assets/js/2.ff0695d0.js"><link rel="prefetch" href="/assets/js/20.7c41a12f.js"><link rel="prefetch" href="/assets/js/21.fc80806c.js"><link rel="prefetch" href="/assets/js/22.40f1a2c2.js"><link rel="prefetch" href="/assets/js/23.099cf4dd.js"><link rel="prefetch" href="/assets/js/24.27062614.js"><link rel="prefetch" href="/assets/js/25.db00c68a.js"><link rel="prefetch" href="/assets/js/26.75eced52.js"><link rel="prefetch" href="/assets/js/27.141748c3.js"><link rel="prefetch" href="/assets/js/28.4a2b2f52.js"><link rel="prefetch" href="/assets/js/29.f700ec1a.js"><link rel="prefetch" href="/assets/js/3.51e60054.js"><link rel="prefetch" href="/assets/js/30.303c9639.js"><link rel="prefetch" href="/assets/js/31.61e0e098.js"><link rel="prefetch" href="/assets/js/32.2e93f8ac.js"><link rel="prefetch" href="/assets/js/33.7197ed8c.js"><link rel="prefetch" href="/assets/js/34.70cab748.js"><link rel="prefetch" href="/assets/js/35.a2938760.js"><link rel="prefetch" href="/assets/js/36.344d5f62.js"><link rel="prefetch" href="/assets/js/37.ccd6ef99.js"><link rel="prefetch" href="/assets/js/38.f747c3ac.js"><link rel="prefetch" href="/assets/js/39.0014b129.js"><link rel="prefetch" href="/assets/js/40.4bcb8f39.js"><link rel="prefetch" href="/assets/js/41.54d85b43.js"><link rel="prefetch" href="/assets/js/42.8116cd4c.js"><link rel="prefetch" href="/assets/js/43.6f3e70fc.js"><link rel="prefetch" href="/assets/js/44.d6d8abff.js"><link rel="prefetch" href="/assets/js/45.cd9babd6.js"><link rel="prefetch" href="/assets/js/46.cb867dfa.js"><link rel="prefetch" href="/assets/js/47.070d730e.js"><link rel="prefetch" href="/assets/js/48.0cdf0dc3.js"><link rel="prefetch" href="/assets/js/49.3c348071.js"><link rel="prefetch" href="/assets/js/5.d96a2b8c.js"><link rel="prefetch" href="/assets/js/50.70221375.js"><link rel="prefetch" href="/assets/js/51.4d3bfe99.js"><link rel="prefetch" href="/assets/js/52.290b62dd.js"><link rel="prefetch" href="/assets/js/53.bdead276.js"><link rel="prefetch" href="/assets/js/54.af6c538d.js"><link rel="prefetch" href="/assets/js/55.7aa7f892.js"><link rel="prefetch" href="/assets/js/56.fd25720a.js"><link rel="prefetch" href="/assets/js/57.dd9ffee0.js"><link rel="prefetch" href="/assets/js/58.a9fa94d5.js"><link rel="prefetch" href="/assets/js/59.b24205ab.js"><link rel="prefetch" href="/assets/js/6.fff243bb.js"><link rel="prefetch" href="/assets/js/60.c48f9f3c.js"><link rel="prefetch" href="/assets/js/61.6ae343dc.js"><link rel="prefetch" href="/assets/js/62.d5032578.js"><link rel="prefetch" href="/assets/js/63.0566b7b0.js"><link rel="prefetch" href="/assets/js/64.39f75b2c.js"><link rel="prefetch" href="/assets/js/65.cafbd489.js"><link rel="prefetch" href="/assets/js/66.d2dbf74b.js"><link rel="prefetch" href="/assets/js/68.161678f2.js"><link rel="prefetch" href="/assets/js/69.788810b6.js"><link rel="prefetch" href="/assets/js/7.170b11d7.js"><link rel="prefetch" href="/assets/js/70.fbb3b202.js"><link rel="prefetch" href="/assets/js/71.a3d8b7aa.js"><link rel="prefetch" href="/assets/js/72.46d6c318.js"><link rel="prefetch" href="/assets/js/73.e99efe3a.js"><link rel="prefetch" href="/assets/js/74.fd9eaff7.js"><link rel="prefetch" href="/assets/js/75.6782e97d.js"><link rel="prefetch" href="/assets/js/76.06524762.js"><link rel="prefetch" href="/assets/js/77.aec65f81.js"><link rel="prefetch" href="/assets/js/78.d7ce09bc.js"><link rel="prefetch" href="/assets/js/79.28e1de1e.js"><link rel="prefetch" href="/assets/js/8.13e5b4ae.js"><link rel="prefetch" href="/assets/js/80.917ff461.js"><link rel="prefetch" href="/assets/js/81.745e410a.js"><link rel="prefetch" href="/assets/js/82.9ef78695.js"><link rel="prefetch" href="/assets/js/83.a4ce6c69.js"><link rel="prefetch" href="/assets/js/84.5c274b85.js"><link rel="prefetch" href="/assets/js/85.1991c579.js"><link rel="prefetch" href="/assets/js/86.bdab760b.js"><link rel="prefetch" href="/assets/js/vuejs-paginate.8d41f623.js">
    <link rel="stylesheet" href="/assets/css/0.styles.bb0c19ce.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div id="vuepress-theme-blog__global-layout"><section id="header-wrapper"><header id="header"><div class="header-wrapper"><div class="title"><a href="/" class="nav-link home-link">Rafael Neto </a></div> <div class="header-right-wrap"><ul class="nav"><li class="nav-item"><a href="/en/blog/" class="nav-link">English</a></li><li class="nav-item"><a href="/blog/" class="nav-link router-link-active">Blog</a></li><li class="nav-item"><a href="/tag/" class="nav-link">Tags</a></li></ul> <div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></div></header></section> <div id="mobile-header"><div class="mobile-header-bar"><div class="mobile-header-title"><a href="/" class="nav-link mobile-home-link">Rafael Neto </a> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg></div> <div class="mobile-menu-wrapper"><hr class="menu-divider"> <ul class="mobile-nav"><li class="mobile-nav-item"><a href="/en/blog/" class="nav-link">English</a></li><li class="mobile-nav-item"><a href="/blog/" class="nav-link router-link-active">Blog</a></li><li class="mobile-nav-item"><a href="/tag/" class="nav-link">Tags</a></li> <li class="mobile-nav-item"><!----></li></ul></div></div></div> <div class="content-wrapper"><div id="vuepress-theme-blog__post-layout"><article itemscope="itemscope" itemtype="https://schema.org/BlogPosting" class="vuepress-blog-theme-content"><header><h1 itemprop="name headline" class="post-title">
        
      </h1> <div class="post-meta"><!----> <div class="post-meta-date"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clock"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg> <time pubdate itemprop="datePublished" datetime="2023-2-28">
      2023-02-28
    </time></div> <ul itemprop="keywords" class="post-meta-tags"><li class="post-tag" data-v-42ccfcd5><a href="/tag/ASPNETCore" data-v-42ccfcd5><span data-v-42ccfcd5>ASPNETCore</span></a></li><li class="post-tag" data-v-42ccfcd5><a href="/tag/AzureAD" data-v-42ccfcd5><span data-v-42ccfcd5>AzureAD</span></a></li><li class="post-tag" data-v-42ccfcd5><a href="/tag/OAuth2" data-v-42ccfcd5><span data-v-42ccfcd5>OAuth2</span></a></li><li class="post-tag" data-v-42ccfcd5><a href="/tag/OIDC" data-v-42ccfcd5><span data-v-42ccfcd5>OIDC</span></a></li><li class="post-tag" data-v-42ccfcd5><a href="/tag/seguridad" data-v-42ccfcd5><span data-v-42ccfcd5>seguridad</span></a></li></ul></div></header> <div itemprop="articleBody" class="content__default"><h1 id="flujos-de-autorizacion-con-oauth-2-0-y-openid-connect"><a href="#flujos-de-autorizacion-con-oauth-2-0-y-openid-connect" class="header-anchor">#</a> Flujos de autorización con OAuth 2.0 y OpenID Connect</h1> <!----> <p>Español | <a href="/en/blog/authorization-flows-oauth-2-0-openid-connect/">English</a></p> <p>Un flujo de autorización es lo que permite que una aplicación cliente, como aplicaciones web, aplicaciones de escritorio, teléfonos móviles, dispositivos IoT y otros consumidores, obtengan acceso autorizado a recursos protegidos, como APIs web y archivos entre otros. OAuth 2.0 se centra en la simplicidad para el desarrollador del cliente al tiempo que proporciona flujos de autorización específicos, que se enriquecen mediante el uso de OpenID Connect como una capa de identidad simple sobre el protocolo OAuth 2.0.</p> <h2 id="oauth-2-0"><a href="#oauth-2-0" class="header-anchor">#</a> OAuth 2.0</h2> <p>OAuth 2.0 es un marco de autorización estándar que permite un mayor control sobre el alcance de una aplicación y los flujos de autorización a través de múltiples sistemas. OAuth 2.0 tiene que ver con el acceso a recursos con alcances granulares que le otorgan permisos en nombre de un usuario.</p> <p>Antes de OpenID Connect, se usaba OAuth 2.0 para autenticación y autorización, pero el problema era que con OAuth no teníamos la información del usuario porque a OAuth no le importa quién es el usuario. OAuth fue diseñado para permisos y alcances, pero hubieron muchas empresas (Facebook, Google, Twitter, etc.) que usaban OAuth 2.0 para su proceso de autenticación. Todos ellos necesitaron crear una implementación personalizada para suplir las carencias del protocolo relacionadas con la identificación del usuario (y por eso cierta documentación nos confunde).</p> <p>OAuth 2.0 se usó para delegar la autorización, así como en exceso para la autenticación con inicio de sesión simple, SSO e inicio de sesión en aplicaciones móviles.</p> <h2 id="openid-connect-oidc"><a href="#openid-connect-oidc" class="header-anchor">#</a> OpenID Connect (OIDC)</h2> <p>OpenID Connect es una capa de identidad adicional (una extensión) sobre el protocolo OAuth 2.0 mediante el uso del flujo de mensajes estandarizado de OAuth 2.0 basado en JSON y HTTP, para proporcionar un nuevo protocolo de servicios de identidad para la autenticación, que permite a las aplicaciones verificar y recibir la información del perfil de usuario de los usuarios registrados.</p> <blockquote><p>OAuth 2.0 + Identidad + Autenticación = <strong>OpenID Connect</strong></p></blockquote> <p>OpenID Connect añade a OAuth 2.0:</p> <ul><li>Token de identidad que representa cierta información del usuario.</li> <li>Puntos de acceso para verificar la información de identidad y obtener más información del usuario.</li> <li>Ámbitos (<em>scopes</em>) y notificaciones (<em>claims</em>) estándar específicos para la identidad.</li> <li>Implementación estandarizada.</li> <li>Un documento de descubrimiento en el que el servidor publica sus metadatos a través de la conocida URL (<em>https://my-iodc-server.com/.well-known/openid-configuration</em>).</li></ul> <p>OpenID Connect permite a los desarrolladores liberarse de la difícil y peligrosa responsabilidad de almacenar y gestionar las contraseñas de las personas, también identifica los atributos personales que pueden intercambiarse entre los proveedores de identidad y las aplicaciones que los utilizan, e incluye un paso de aprobación en el que el usuario puede consentir o denegar el intercambio de esta información.</p> <p>Por lo tanto, deberíamos utilizar OAuth 2.0 para la autorización, es decir, para conceder acceso a las API y obtener acceso a los datos de usuario en otros sistemas, y OpenID Connect para la autenticación, es decir, para registrar al usuario y para que un usuario esté disponible en otro sistema.</p> <h3 id="implementaciones-de-openid-connect"><a href="#implementaciones-de-openid-connect" class="header-anchor">#</a> Implementaciones de OpenID Connect</h3> <p><a href="https://openid.net/developers/certified/" target="_blank" rel="noopener noreferrer">Bibliotecas, servidores, servicios y proveedores con implementaciones certificadas de OpenID Connect<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>.</p> <h3 id="conceptos-clave"><a href="#conceptos-clave" class="header-anchor">#</a> Conceptos clave</h3> <ul><li><em>Client ID</em>: Identifica al cliente (aplicación) en el servidor de autorización.</li> <li><em>Client secret</em>: La contraseña/clave privada que sólo conocen el cliente y el servidor de autorización.</li> <li><em>Authorization code</em>: Es un código temporal devuelto por el servidor de autenticación y utilizado con el secreto de cliente por la aplicación para intercambiar por el token de acceso y el token de identificación.</li> <li><em>Access token</em> (token de acceso): Es la clave que utilizará el cliente para solicitar datos al servidor de recursos.</li> <li><em>ID token</em> (token de identificación): Es la información del perfil de usuario devuelta de forma segura por el servidor de autenticación en formato JWT. Puede ampliarse llamando al endpoint <em>user_info</em> y debe ser comprobado por el cliente para asegurarse de que el <em>aud</em> (audiencia, es decir, cliente) coincide con su <em>client_id</em> y el <em>iss</em> (autoridad emisora) coincide con el dominio (o subdominio) del emisor del <em>client_id</em>.</li> <li><em>Access token</em>: Es una cadena OAuth utilizada en un sistema de autorización basado en tokens para realizar peticiones que permitan a una aplicación acceder a una API o servidor de recursos. Son los que se utilizan como <em>Bearer tokens</em>.</li> <li><em>Refresh token</em>: Es un token especial devuelto durante el intercambio de códigos de autenticación y proporciona al cliente la posibilidad de tener acceso continuo a los recursos mientras el usuario no está utilizando la aplicación. Permite a una aplicación obtener un nuevo token de acceso sin preguntar al usuario a través del flujo de token de refresco. Cuando se utiliza en el canal frontal para refrescar el token de acceso, está protegido por una cookie HTTP Only o utilizando una nueva técnica llamada <em>Refresh Token Rotation</em> en la que se genera un nuevo token de refresco con cada solicitud. <em>Un refresh token puede comprometer la seguridad de la aplicación permitiendo a alguien conectarse al sistema.</em></li> <li><em>Scopes</em> (ámbitos): Los token de acceso permiten hacer cosas específicas y los scopes son la forma de definir de forma granular, como el cliente (aplicación) solicita ese acceso (leer email, escribir email, borrar foto, etc). Es el mecanismo utilizado para limitar el acceso a los datos de un usuario desde una aplicación.</li> <li><em>opendid</em> scope: Con este scope, la petición OAuth 2.0, se convierte en una petición OpenID Connect. Esto significa que el cliente está solicitando un identificador (<em>id</em>) para el usuario. Otros ámbitos importantes de OpenID Connect son:
<ul><li><em>profile</em>: devuelve la información del perfil (definida por el servidor y el usuario) como nombre, apellido o foto.</li> <li><em>email</em>: devuelve el correo electrónico del usuario.</li> <li><em>address</em>: la dirección del usuario.</li> <li><em>phone</em>: el teléfono del usuario.</li></ul></li></ul> <h3 id="flujo-de-codigo-de-autorizacion-de-openid-connect"><a href="#flujo-de-codigo-de-autorizacion-de-openid-connect" class="header-anchor">#</a> Flujo de código de autorización de OpenID Connect</h3> <p>El flujo de código de autorización (Authorization Code Flow) es un flujo de OpenID Connect (basado en el flujo de código de autorización de OAuth 2.0 ampliado con funciones de OIDC) diseñado específicamente para autenticar aplicaciones del lado del servidor, ya que debe producirse un intercambio de claves en un entorno seguro (back channel).</p> <h4 id="¿como-funciona"><a href="#¿como-funciona" class="header-anchor">#</a> ¿Cómo funciona?</h4> <ol><li>El usuario hace clic en el enlace de inicio de sesión que desencadena una acción en el lado del servidor de la aplicación (back channel).</li> <li>El lado del servidor de la aplicación solicita un <em>code</em> de autorización al servidor de autorización a través del punto de acceso <em>authorize</em>. La solicitud incluye el ámbito <em>openid</em> además de otros ámbitos, el <em>client id</em>, el parámetro <em>state</em> (valor utilizado para mantener el estado entre la solicitud y la respuesta) e indica que requiere el tipo de respuesta <em>code</em>.</li> <li>El servidor de autorización redirige al usuario a la página de inicio de sesión.</li> <li>El usuario se autentica y consiente (o deniega) los ámbitos solicitados.</li> <li>Si el usuario concede el acceso a la aplicación, el servidor de autorización responde con un <em>authorization code</em> y el <em>state</em> al lado del servidor de la aplicación.</li> <li>El lado del servidor de la aplicación solicita el intercambio del <em>access token</em> y el <em>id token</em> (opcionalmente un <em>refresh token</em>) al servidor de autenticación a través del punto de acceso <em>token</em>, utilizando el <em>authorization core</em> original, el <em>client id</em> y el <em>client secret</em>.</li> <li>El servidor de autorización verifica la solicitud.</li> <li>El servidor de autorización responde con un <em>access token</em> y un <em>id token</em> (opcionalmente un <em>refresh token</em>) al servidor de la aplicación.</li> <li>En este paso, la aplicación puede crear una sesión de usuario o registrar al nuevo usuario en la aplicación utilizando la información del perfil de usuario.</li> <li>El lado del servidor de la aplicación realiza llamadas a la API utilizando el <em>access token</em> mediante la autorización <em>Bearer</em> en la cabecera HTTP.</li> <li>La API responde con datos al servidor de la aplicación.</li></ol> <h3 id="flujo-de-codigo-de-autorizacion-con-pkce"><a href="#flujo-de-codigo-de-autorizacion-con-pkce" class="header-anchor">#</a> Flujo de código de autorización con PKCE</h3> <p>El flujo de código de autorización con PKCE (Authorization Code Flow with PKCE) se usa para evitar el ataque de interceptación de código de autorización podemos utilizar PKCE que amplía el flujo de código de autorización impidiendo <a href="https://developer.mozilla.org/es/docs/Glossary/CSRF" target="_blank" rel="noopener noreferrer">CSRF<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>. PKCE, pronunciado &quot;pixy&quot; es un acrónimo de <em>Proof Key for Code Exchange</em>. Este flujo incluye nuevos elementos PKCE (<em>code verifier</em>, <em>code challenge</em> y <em>code challenge method</em>) en varios pasos del flujo encargados de proteger la comunicación entre el cliente y el servidor de autenticación.</p> <p>Fue originalmente diseñado para proteger el flujo de código de autorización en aplicaciones móviles donde no podemos almacenar de forma segura un secreto de cliente, pero actualmente es el <strong>flujo recomendado para la mayoría de las aplicaciones</strong> como aplicaciones web con servidor backend, SPAs con y sin backend, aplicaciones nativas y móviles.</p> <h4 id="¿como-funciona-2"><a href="#¿como-funciona-2" class="header-anchor">#</a> ¿Cómo funciona?</h4> <ol><li>El usuario hace clic en el enlace de inicio de sesión.</li> <li>El cliente/aplicación (del lado del cliente/canal frontal o del lado del servidor/canal posterior), crea un <em>code verifier</em> criptográficamente aleatorio y a partir de ahí genera un <em>code challenge</em>.</li> <li>El cliente solicita un <em>code</em> de autorización al servidor de autorización a través del punto de acceso <em>authorize</em>. La solicitud incluye el <em>code challenge</em> y el parámetro <em>state</em> (valor utilizado para mantener el estado entre la solicitud y la respuesta).</li> <li>El servidor de autorización redirige al usuario a la página de inicio de sesión.</li> <li>El usuario se autentica y consiente (o deniega) los ámbitos solicitados.</li> <li>Si el usuario concede el acceso a la aplicación, el servidor de autorización almacena el <em>code challenge</em> y responde con un <em>authorization code</em> a la aplicación.</li> <li>La aplicación solicita el intercambio del <em>access token</em> y el <em>id token</em> (opcionalmente un <em>refresh token</em>) al servidor de autenticación a través del punto de acceso <em>token</em>, utilizando el <em>authorization code</em> original y el <em>code verifier</em>.</li> <li>El servidor de autorización verifica el <em>code challenge</em> y el <em>code verifier</em>.</li> <li>El servidor de autorización responde con un <em>access token</em> y un <em>id token</em> (opcionalmente un <em>refresh token</em>) a la aplicación.</li> <li>En este paso, la aplicación puede crear una sesión de usuario o registrar el nuevo usuario en la aplicación utilizando la información del perfil de usuario.</li> <li>La aplicación realiza llamadas a la API utilizando el <em>access token</em> utilizando la autorización <em>Bearer</em> en la cabecera HTTP.</li> <li>La API responde con datos.</li></ol> <p>Flujo de código de autorización OAuth 2.0 con PKCE (así como el Flujo de código de autorización -Authorization Code Flow- del que deriva), permite autenticar en nombre de otro usuario para tener más control sobre los ámbitos de una aplicación y mejora los flujos de autorización a través de múltiples dispositivos. En otras palabras, los desarrolladores que creen aplicaciones para personas en Twitter, GitHub, AWS, Google o PayPal, por ejemplo, tendrán más control sobre la información que su aplicación solicita a sus usuarios, de modo que sólo tendrá que pedir (a través de los ámbitos) a sus usuarios finales los datos y la información que necesite.</p> <blockquote><p>Este moderno protocolo de autorización te permitirá presentar a tus usuarios finales un flujo de consentimiento más ágil para autorizar tu aplicación, en el cual sólo se mostrarán los ámbitos (<em>scopes</em>) específicos que les has solicitado. Esto no sólo reduce la carga de datos, sino que también puede aumentar la confianza de los usuarios. Este flujo se utiliza para conceder acceso a una API u obtener acceso a los datos de los usuarios en otros sistemas y cuando se concede a una aplicación que importe la información de sus usuarios desde otra aplicación.</p></blockquote> <h3 id="flujo-implicito"><a href="#flujo-implicito" class="header-anchor">#</a> Flujo implícito</h3> <p>El flujo implícito (Implicit flow) es un flujo en desuso y utilizado sólo por SPAs que no tienen lado de servidor y no pueden soportar PKCE, por lo tanto es menos seguro y mucho más simple.</p> <h4 id="¿como-funciona-3"><a href="#¿como-funciona-3" class="header-anchor">#</a> ¿Cómo funciona?</h4> <ol><li>El usuario hace clic en el enlace de inicio de sesión que desencadena una acción en la aplicación (front channel).</li> <li>La app solicita el <em>id token</em> al servidor de autorización a través del punto de acceso <em>authorize</em>. La petición incluye el ámbito <em>openid</em> además de otros ámbitos y el <em>client id</em>, el parámetro <em>state</em> (valor utilizado para mantener el estado entre la petición y la respuesta), el <em>redirect_uri</em> donde la app escuchará por la redirección del servidor de identidad, e indicará que requiere el tipo de respuesta <em>id_token</em> (para obtener sólo el <em>id_token</em>) o <em>id_token token</em> (para obtener el <em>id_token</em> y el <em>access_token</em>).</li> <li>El servidor de autorización redirige al usuario a la página de inicio de sesión.</li> <li>El usuario se autentica y consiente (o deniega) los ámbitos solicitados.</li> <li>Si el usuario concede el acceso a la aplicación, el servidor de autorización redirige a la aplicación con un <em>id token</em> y un <em>access token</em> (si se solicita) y el cliente valida el token.</li> <li>En este paso, la aplicación puede realizar llamadas a la API utilizando el <em>access token</em> mediante el <em>Bearer</em> de autorización en la cabecera HTTP.</li> <li>La API responde con datos a la SPA.</li></ol> <h3 id="flujo-de-credenciales-de-cliente"><a href="#flujo-de-credenciales-de-cliente" class="header-anchor">#</a> Flujo de credenciales de cliente</h3> <p>El flujo de credenciales de cliente (Client Credentials Flow) se utiliza en el contexto de la comunicación máquina a máquina (back-end) y utilizando una clave secreta que sólo el sistema conoce para autenticar y autorizar las aplicaciones en segundo plano en lugar de un usuario.</p> <h4 id="¿como-funciona-4"><a href="#¿como-funciona-4" class="header-anchor">#</a> ¿Cómo funciona?</h4> <ol><li>La aplicación solicita el <em>access token</em> al servidor de autorización a través del punto de acceso <em>token</em>, utilizando el <em>client id</em> y el <em>client secret</em>.</li> <li>El servidor de autorización verifica la solicitud.</li> <li>El servidor de autorización responde con un <em>access token</em> a la aplicación.</li> <li>La aplicación realiza llamadas a la API utilizando el <em>access token</em> mediante el <em>Bearer</em> de autorización en la cabecera HTTP.</li> <li>La API responde con datos a la aplicación.</li></ol> <h2 id="conectando-los-usuarios-del-servidor-de-autorizacion-y-los-usuarios-de-la-aplicacion"><a href="#conectando-los-usuarios-del-servidor-de-autorizacion-y-los-usuarios-de-la-aplicacion" class="header-anchor">#</a> Conectando los usuarios del servidor de autorización y los usuarios de la aplicación</h2> <p>Una posible forma de conectar los usuarios del servidor de autorización y los usuarios de la aplicación es cuando la aplicación tiene un almacenamiento de datos de usuario. En ese caso podemos manejar la conexión entre ambos con una notificación/claim (tal vez el correo electrónico del usuario). El caso de uso podría ser:</p> <ol><li>Como paso previo se podría crear el usuario en la aplicación.</li> <li>Cuando el usuario se autentique a través del servidor de identidad, utilizar un claim para que coincida con los datos de la aplicación del usuario.</li> <li>Si el usuario no fue creado anteriormente, registrar el nuevo usuario en la aplicación utilizando la información del perfil del usuario.</li> <li>Crear una sesión de usuario y permitir el uso de la aplicación.</li></ol> <p>Este enfoque permite la posibilidad de utilizar varios servidores de autenticación.</p> <p>Otra forma es cuando no tenemos una tabla de usuarios. En ese caso necesitamos confiar en el sistema del servidor de autenticación y manejarlo usando el perfil de usuario, los <em>scopes</em> y los <em>claims</em> directamente.</p> <blockquote><p><em>¿Cómo podemos utilizar el <em>refresh token</em> para mantener viva una sesión web?</em> La mejor manera de manejar esto es redirigir al usuario al servidor de autenticación y dejar que el servidor de autorización mantenga la sesión para el usuario.</p></blockquote> <h2 id="securizar-una-aplicacion-con-openid-connect-y-azure-ad"><a href="#securizar-una-aplicacion-con-openid-connect-y-azure-ad" class="header-anchor">#</a> Securizar una aplicación con OpenID Connect y Azure AD</h2> <h3 id="¿que-es-azure-active-directory"><a href="#¿que-es-azure-active-directory" class="header-anchor">#</a> ¿Qué es Azure Active Directory?</h3> <p>Azure Active Directory (Azure AD) es el servicio de gestión de acceso e identidad basado en la nube de Microsoft (proveedor de autenticación). Simplifica la autenticación para los desarrolladores proporcionando identidad como servicio. Es compatible con protocolos estándar del sector como OAuth 2.0 y OpenID Connect.</p> <h2 id="crear-un-tenant-de-azure-ad"><a href="#crear-un-tenant-de-azure-ad" class="header-anchor">#</a> Crear un tenant de Azure AD</h2> <p>Un <em>tenant</em> es una instancia de Azure AD que representa a una organización. Es una instancia dedicada de Azure AD que una organización o un desarrollador de aplicaciones recibe cuando la organización o el desarrollador de aplicaciones crea una relación con Microsoft, como la suscripción a Azure, Microsoft 365 o Microsoft Intune.</p> <h2 id="registrar-una-aplicacion-web"><a href="#registrar-una-aplicacion-web" class="header-anchor">#</a> Registrar una aplicación web</h2> <p>Dentro del tenant Azure AD, necesitará un registro para la aplicación. El registro es un registro de detalles de seguridad para la aplicación en Azure AD. Un registro garantiza que Azure AD pueda identificar la aplicación y el usuario. El registro de una aplicación puede incluir soporte para el directorio empresarial y las cuentas Microsoft.</p> <h2 id="configurar-la-aplicacion-para-la-autenticacion"><a href="#configurar-la-aplicacion-para-la-autenticacion" class="header-anchor">#</a> Configurar la aplicación para la autenticación</h2> <p>Hay muchos detalles para garantizar que las especificaciones del protocolo OpenID Connect se siguen correctamente. Para ayudar a los desarrolladores a utilizar OpenID Connect en sus aplicaciones, Microsoft proporciona middleware para facilitar esta comunicación. Este middleware consiste en APIs que incluyen métodos y propiedades que facilitan la interacción con el proveedor de identidad.</p> <div class="language-csharp extra-class"><pre class="language-csharp"><code>services<span class="token punctuation">.</span><span class="token generic-method"><span class="token function">Configure</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>CookiePolicyOptions<span class="token punctuation">&gt;</span></span></span><span class="token punctuation">(</span>options <span class="token operator">=&gt;</span>
    <span class="token punctuation">{</span>
        options<span class="token punctuation">.</span>CheckConsentNeeded <span class="token operator">=</span> context <span class="token operator">=&gt;</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        options<span class="token punctuation">.</span>MinimumSameSitePolicy <span class="token operator">=</span> SameSiteMode<span class="token punctuation">.</span>None<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

services<span class="token punctuation">.</span><span class="token function">AddAuthentication</span><span class="token punctuation">(</span>AzureADDefaults<span class="token punctuation">.</span>AuthenticationScheme<span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">AddAzureAD</span><span class="token punctuation">(</span>options <span class="token operator">=&gt;</span> Configuration<span class="token punctuation">.</span><span class="token function">Bind</span><span class="token punctuation">(</span><span class="token string">&quot;AzureAd&quot;</span><span class="token punctuation">,</span> options<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

services<span class="token punctuation">.</span><span class="token generic-method"><span class="token function">Configure</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>OpenIdConnectOptions<span class="token punctuation">&gt;</span></span></span><span class="token punctuation">(</span>AzureADDefaults<span class="token punctuation">.</span>OpenIdScheme<span class="token punctuation">,</span> options <span class="token operator">=&gt;</span>
    <span class="token punctuation">{</span>
        options<span class="token punctuation">.</span>Authority <span class="token operator">=</span> options<span class="token punctuation">.</span>Authority <span class="token operator">+</span> <span class="token string">&quot;/v2.0/&quot;</span><span class="token punctuation">;</span>
        options<span class="token punctuation">.</span>TokenValidationParameters<span class="token punctuation">.</span>ValidateIssuer <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>Puedes utilizar el middleware de autenticación para registrar usuarios de uno o más tenants de Azure AD. El middleware se inicializa en el archivo <em>Startup.Auth.cs</em>, pasándole el ID de cliente de la aplicación y la URL del tenant de Azure AD donde está registrada la aplicación. A continuación, el middleware se encarga de:</p> <ul><li>Descargar los metadatos de Azure AD.</li> <li>Procesar las respuestas de autenticación de OpenID Connect.</li> <li>Integración con la cookie de sesión.</li></ul> <blockquote><p>Si quieres saber más sobre autenticación y autorización en ASP.NET Core, te recomiendo que le eches un vistazo a este otro artículo que he creado sobre <a href="/blog/autenticacion-autorizacion-jwt-bearer-aspnet-core/">Autenticación y autorización basada en token (JWT Bearer) con ASP.NET Core</a>.</p></blockquote> <hr> <!----></div> <footer><!----> <hr> <!----></footer></article> <div class="sticker vuepress-toc"><div class="vuepress-toc-item vuepress-toc-h2 active"><a href="#oauth-2-0" title="OAuth 2.0">OAuth 2.0</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#openid-connect-oidc" title="OpenID Connect (OIDC)">OpenID Connect (OIDC)</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#implementaciones-de-openid-connect" title="Implementaciones de OpenID Connect">Implementaciones de OpenID Connect</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#conceptos-clave" title="Conceptos clave">Conceptos clave</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#flujo-de-codigo-de-autorizacion-de-openid-connect" title="Flujo de código de autorización de OpenID Connect">Flujo de código de autorización de OpenID Connect</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#flujo-de-codigo-de-autorizacion-con-pkce" title="Flujo de código de autorización con PKCE">Flujo de código de autorización con PKCE</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#flujo-implicito" title="Flujo implícito">Flujo implícito</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#flujo-de-credenciales-de-cliente" title="Flujo de credenciales de cliente">Flujo de credenciales de cliente</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#conectando-los-usuarios-del-servidor-de-autorizacion-y-los-usuarios-de-la-aplicacion" title="Conectando los usuarios del servidor de autorización y los usuarios de la aplicación">Conectando los usuarios del servidor de autorización y los usuarios de la aplicación</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#securizar-una-aplicacion-con-openid-connect-y-azure-ad" title="Securizar una aplicación con OpenID Connect y Azure AD">Securizar una aplicación con OpenID Connect y Azure AD</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#¿que-es-azure-active-directory" title="¿Qué es Azure Active Directory?">¿Qué es Azure Active Directory?</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#crear-un-tenant-de-azure-ad" title="Crear un tenant de Azure AD">Crear un tenant de Azure AD</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#registrar-una-aplicacion-web" title="Registrar una aplicación web">Registrar una aplicación web</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#configurar-la-aplicacion-para-la-autenticacion" title="Configurar la aplicación para la autenticación">Configurar la aplicación para la autenticación</a></div></div></div></div> <footer class="footer" data-v-fdbf4940><div class="footer-left-wrap" data-v-fdbf4940><ul class="contact" data-v-fdbf4940><li class="contact-item" data-v-fdbf4940><a href="https://x.com/RNeto" target="_blank" rel="noopener noreferrer" class="nav-link external" data-v-fdbf4940><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-twitter" data-v-fdbf4940><path d="M23 3a10.9 10.9 0 0 1-3.14 1.53 4.48 4.48 0 0 0-7.86 3v1A10.66 10.66 0 0 1 3 4s-4 9 5 13a11.64 11.64 0 0 1-7 2c9 5 20 0 20-11.5a4.5 4.5 0 0 0-.08-.83A7.72 7.72 0 0 0 23 3z" data-v-fdbf4940></path></svg>
          
        </a></li></ul></div> <div class="footer-right-wrap" data-v-fdbf4940><ul class="copyright" data-v-fdbf4940><li class="copyright-item" data-v-fdbf4940><a href="/index.html" class="nav-link" data-v-fdbf4940>Rafael Neto © 2025</a></li></ul></div></footer></div><div class="global-ui"><!----><!----></div></div>
    <script src="/assets/js/app.ee019d85.js" defer></script><script src="/assets/js/4.35e6b205.js" defer></script><script src="/assets/js/1.801c1b6e.js" defer></script><script src="/assets/js/67.08618c54.js" defer></script>
  </body>
</html>
